//
//  Dial.swift
//
//  Created on May 25, 2019.
//
//  Generated by PaintCode Plugin for Sketch
//  http://www.paintcodeapp.com/sketch
//

import UIKit



class Dial: NSObject
{
	
	
	//MARK: - Canvas Drawings
	
	/// Page 1
	
	class func drawDraw(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit)
	{
		/// General Declarations
		let context = UIGraphicsGetCurrentContext()!
		let baseTransform = context.userSpaceToDeviceSpaceTransform.inverted()
		
		/// Resize to Target Frame
		context.saveGState()
		let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
		context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
		context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)
		
		/// tickTask-oval5
		let tickTaskoval5 = UIBezierPath()
		tickTaskoval5.move(to: CGPoint(x: 43.36, y: 86.72))
		tickTaskoval5.addCurve(to: CGPoint(x: 86.72, y: 43.36), controlPoint1: CGPoint(x: 67.31, y: 86.72), controlPoint2: CGPoint(x: 86.72, y: 67.31))
		tickTaskoval5.addCurve(to: CGPoint(x: 43.36, y: 0), controlPoint1: CGPoint(x: 86.72, y: 19.41), controlPoint2: CGPoint(x: 67.31, y: 0))
		tickTaskoval5.addCurve(to: CGPoint(x: 0, y: 43.36), controlPoint1: CGPoint(x: 19.41, y: 0), controlPoint2: CGPoint(x: 0, y: 19.41))
		tickTaskoval5.addCurve(to: CGPoint(x: 43.36, y: 86.72), controlPoint1: CGPoint(x: 0, y: 67.31), controlPoint2: CGPoint(x: 19.41, y: 86.72))
		tickTaskoval5.close()
		context.saveGState()
		context.translateBy(x: 6.64, y: 6.64)
		context.saveGState()
		context.beginPath()
		context.addPath(tickTaskoval5.cgPath)
		context.addRect(tickTaskoval5.bounds.insetBy(dx: -4, dy: -6))
		context.clip(using: .evenOdd)
		context.translateBy(x: -91.72, y: 0)
		do
		{
			let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
			let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
			let baseOffset = context.convertToDeviceSpace(CGPoint(x: 91.72, y: 2)).applying(baseTransform)
			let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
			let shadowBlur: CGFloat = 4 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
			context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor(white: 0, alpha: 0.8).cgColor)
		}
		UIColor.black.setFill()
		tickTaskoval5.fill()
		context.restoreGState()
		UIColor(white: 0.11, alpha: 1).setFill()
		tickTaskoval5.fill()
		context.restoreGState()
		
		/// tickTask-oval
		let tickTaskoval = UIBezierPath()
		tickTaskoval.move(to: CGPoint(x: 43.36, y: 86.72))
		tickTaskoval.addCurve(to: CGPoint(x: 86.72, y: 43.36), controlPoint1: CGPoint(x: 67.31, y: 86.72), controlPoint2: CGPoint(x: 86.72, y: 67.31))
		tickTaskoval.addCurve(to: CGPoint(x: 43.36, y: 0), controlPoint1: CGPoint(x: 86.72, y: 19.41), controlPoint2: CGPoint(x: 67.31, y: 0))
		tickTaskoval.addCurve(to: CGPoint(x: 0, y: 43.36), controlPoint1: CGPoint(x: 19.41, y: 0), controlPoint2: CGPoint(x: 0, y: 19.41))
		tickTaskoval.addCurve(to: CGPoint(x: 43.36, y: 86.72), controlPoint1: CGPoint(x: 0, y: 67.31), controlPoint2: CGPoint(x: 19.41, y: 86.72))
		tickTaskoval.close()
		context.saveGState()
		context.translateBy(x: 6.64, y: 6.64)
		context.saveGState()
		tickTaskoval.addClip()
		context.drawLinearGradient(CGGradient(colorsSpace: nil, colors: [
					UIColor(white: 1, alpha: 0.2).cgColor,
					UIColor(white: 0, alpha: 0.4).cgColor,
				] as CFArray, locations: [0, 1])!,
			start: CGPoint(x: 43.36, y: 0),
			end: CGPoint(x: 43.36, y: 86.72),
			options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
		context.restoreGState()
		tickTaskoval.lineWidth = 0.5
		UIColor(white: 1, alpha: 0.3).setStroke()
		tickTaskoval.stroke()
		context.restoreGState()
		
		/// tickTask-oval4
		let tickTaskoval4 = UIBezierPath()
		tickTaskoval4.move(to: CGPoint(x: 41.6, y: 83.2))
		tickTaskoval4.addCurve(to: CGPoint(x: 83.2, y: 41.6), controlPoint1: CGPoint(x: 64.58, y: 83.2), controlPoint2: CGPoint(x: 83.2, y: 64.58))
		tickTaskoval4.addCurve(to: CGPoint(x: 41.6, y: 0), controlPoint1: CGPoint(x: 83.2, y: 18.63), controlPoint2: CGPoint(x: 64.58, y: 0))
		tickTaskoval4.addCurve(to: CGPoint(x: 0, y: 41.6), controlPoint1: CGPoint(x: 18.63, y: 0), controlPoint2: CGPoint(x: 0, y: 18.63))
		tickTaskoval4.addCurve(to: CGPoint(x: 41.6, y: 83.2), controlPoint1: CGPoint(x: 0, y: 64.58), controlPoint2: CGPoint(x: 18.63, y: 83.2))
		tickTaskoval4.close()
		context.saveGState()
		context.translateBy(x: 8.4, y: 8.4)
		UIColor(white: 0.11, alpha: 1).setFill()
		tickTaskoval4.fill()
		context.restoreGState()
		
		/// tickTask-oval2
		let tickTaskoval2 = UIBezierPath()
		tickTaskoval2.move(to: CGPoint(x: 39.84, y: 79.69))
		tickTaskoval2.addCurve(to: CGPoint(x: 79.69, y: 39.84), controlPoint1: CGPoint(x: 61.85, y: 79.69), controlPoint2: CGPoint(x: 79.69, y: 61.85))
		tickTaskoval2.addCurve(to: CGPoint(x: 39.84, y: 0), controlPoint1: CGPoint(x: 79.69, y: 17.84), controlPoint2: CGPoint(x: 61.85, y: 0))
		tickTaskoval2.addCurve(to: CGPoint(x: 0, y: 39.84), controlPoint1: CGPoint(x: 17.84, y: 0), controlPoint2: CGPoint(x: 0, y: 17.84))
		tickTaskoval2.addCurve(to: CGPoint(x: 39.84, y: 79.69), controlPoint1: CGPoint(x: 0, y: 61.85), controlPoint2: CGPoint(x: 17.84, y: 79.69))
		tickTaskoval2.close()
		context.saveGState()
		context.translateBy(x: 10.16, y: 10.16)
		context.saveGState()
		tickTaskoval2.addClip()
		context.drawLinearGradient(CGGradient(colorsSpace: nil, colors: [
					UIColor(white: 0, alpha: 0.4).cgColor,
					UIColor(white: 1, alpha: 0.1).cgColor,
				] as CFArray, locations: [0, 1])!,
			start: CGPoint(x: 39.84, y: 0),
			end: CGPoint(x: 39.84, y: 79.69),
			options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
		context.restoreGState()
		context.restoreGState()
		
		/// tickTask-oval3
		let tickTaskoval3 = UIBezierPath()
		tickTaskoval3.move(to: CGPoint(x: 38.09, y: 76.17))
		tickTaskoval3.addCurve(to: CGPoint(x: 76.17, y: 38.09), controlPoint1: CGPoint(x: 59.12, y: 76.17), controlPoint2: CGPoint(x: 76.17, y: 59.12))
		tickTaskoval3.addCurve(to: CGPoint(x: 38.09, y: 0), controlPoint1: CGPoint(x: 76.17, y: 17.05), controlPoint2: CGPoint(x: 59.12, y: 0))
		tickTaskoval3.addCurve(to: CGPoint(x: 0, y: 38.09), controlPoint1: CGPoint(x: 17.05, y: 0), controlPoint2: CGPoint(x: 0, y: 17.05))
		tickTaskoval3.addCurve(to: CGPoint(x: 38.09, y: 76.17), controlPoint1: CGPoint(x: 0, y: 59.12), controlPoint2: CGPoint(x: 17.05, y: 76.17))
		tickTaskoval3.close()
		context.saveGState()
		context.translateBy(x: 11.91, y: 11.91)
		UIColor(white: 0.11, alpha: 1).setFill()
		tickTaskoval3.fill()
		context.restoreGState()
		
		/// Shape
		let shape = UIBezierPath()
		shape.move(to: CGPoint(x: 10.01, y: 31.28))
		shape.addCurve(to: CGPoint(x: 4.99, y: 32.56), controlPoint1: CGPoint(x: 8.23, y: 30.26), controlPoint2: CGPoint(x: 5.99, y: 30.82))
		shape.addCurve(to: CGPoint(x: 6.4, y: 37.54), controlPoint1: CGPoint(x: 3.99, y: 34.28), controlPoint2: CGPoint(x: 4.62, y: 36.52))
		shape.addLine(to: CGPoint(x: 6.44, y: 37.57))
		shape.addCurve(to: CGPoint(x: 11.42, y: 36.27), controlPoint1: CGPoint(x: 8.21, y: 38.56), controlPoint2: CGPoint(x: 10.43, y: 37.98))
		shape.addCurve(to: CGPoint(x: 10.01, y: 31.28), controlPoint1: CGPoint(x: 12.42, y: 34.53), controlPoint2: CGPoint(x: 11.78, y: 32.31))
		shape.close()
		shape.move(to: CGPoint(x: 10.68, y: 2.08))
		shape.addCurve(to: CGPoint(x: 16.26, y: 32.68), controlPoint1: CGPoint(x: 10.98, y: 3.3), controlPoint2: CGPoint(x: 16.26, y: 32.68))
		shape.addCurve(to: CGPoint(x: 8.2, y: 42.38), controlPoint1: CGPoint(x: 17.24, y: 38.14), controlPoint2: CGPoint(x: 13.13, y: 42.38))
		shape.addCurve(to: CGPoint(x: 0.15, y: 32.68), controlPoint1: CGPoint(x: 3.29, y: 42.38), controlPoint2: CGPoint(x: -0.84, y: 38.14))
		shape.addCurve(to: CGPoint(x: 5.72, y: 2.08), controlPoint1: CGPoint(x: 0.15, y: 32.68), controlPoint2: CGPoint(x: 5.56, y: 2.74))
		shape.addCurve(to: CGPoint(x: 8.2, y: 0), controlPoint1: CGPoint(x: 6.03, y: 0.85), controlPoint2: CGPoint(x: 6.93, y: 0))
		shape.addCurve(to: CGPoint(x: 10.68, y: 2.08), controlPoint1: CGPoint(x: 9.47, y: 0), controlPoint2: CGPoint(x: 10.38, y: 0.85))
		shape.close()
		context.saveGState()
		context.translateBy(x: 41.8, y: 15.69)
		context.saveGState()
		context.beginPath()
		context.addPath(shape.cgPath)
		context.addRect(shape.bounds.insetBy(dx: -22, dy: -23))
		context.clip(using: .evenOdd)
		context.translateBy(x: -59.41, y: 0)
		do
		{
			let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
			let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
			let baseOffset = context.convertToDeviceSpace(CGPoint(x: 59.41, y: 1)).applying(baseTransform)
			let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
			let shadowBlur: CGFloat = 2 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
			context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor(white: 0, alpha: 0.2).cgColor)
		}
		context.beginTransparencyLayer(auxiliaryInfo: nil)
		do
		{
			UIColor.black.setFill()
			shape.fill()
			context.saveGState()
			shape.lineWidth = 2
			UIColor.black.setStroke()
			shape.stroke()
			context.restoreGState()
		}
		context.endTransparencyLayer()
		context.restoreGState()
		context.saveGState()
		context.beginPath()
		context.addPath(shape.cgPath)
		context.addRect(shape.bounds.insetBy(dx: -26, dy: -24))
		context.clip(using: .evenOdd)
		context.translateBy(x: -63.41, y: 0)
		do
		{
			let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
			let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
			let baseOffset = context.convertToDeviceSpace(CGPoint(x: 65.41, y: 0)).applying(baseTransform)
			let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
			let shadowBlur: CGFloat = 4 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
			context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor(white: 0, alpha: 0.5).cgColor)
		}
		context.beginTransparencyLayer(auxiliaryInfo: nil)
		do
		{
			UIColor.black.setFill()
			shape.fill()
			context.saveGState()
			shape.lineWidth = 2
			UIColor.black.setStroke()
			shape.stroke()
			context.restoreGState()
		}
		context.endTransparencyLayer()
		context.restoreGState()
		UIColor(hue: 0.42, saturation: 0.9, brightness: 1, alpha: 1).setFill()
		shape.fill()
		context.saveGState()
		UIRectClip(shape.bounds)
		context.setShadow(offset: CGSize.zero, blur: 0, color: nil)
		context.setAlpha(0.5)
		context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
		do
		{
			UIColor.white.setFill()
			shape.fill()
			context.setBlendMode(.destinationOut)
			context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
			do
			{
				context.translateBy(x: -16.41, y: 0)
				do
				{
					let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
					let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
					let baseOffset = context.convertToDeviceSpace(CGPoint(x: 16.41, y: 1)).applying(baseTransform)
					let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
					let shadowBlur: CGFloat = 0 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
					context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor.black.cgColor)
				}
				UIColor.black.setFill()
				shape.fill()
			}
			context.endTransparencyLayer()
		}
		context.endTransparencyLayer()
		context.restoreGState()
		context.saveGState()
		UIRectClip(shape.bounds)
		context.setShadow(offset: CGSize.zero, blur: 0, color: nil)
		context.setAlpha(0.5)
		context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
		do
		{
			UIColor.black.setFill()
			shape.fill()
			context.setBlendMode(.destinationOut)
			context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
			do
			{
				context.translateBy(x: -16.41, y: 0)
				do
				{
					let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
					let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
					let baseOffset = context.convertToDeviceSpace(CGPoint(x: 16.41, y: -1)).applying(baseTransform)
					let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
					let shadowBlur: CGFloat = 0 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
					context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor.black.cgColor)
				}
				UIColor.black.setFill()
				shape.fill()
			}
			context.endTransparencyLayer()
		}
		context.endTransparencyLayer()
		context.restoreGState()
		context.saveGState()
		shape.lineWidth = 2
		context.beginPath()
		context.addPath(shape.cgPath)
		context.clip(using: .evenOdd)
		UIColor(white: 1, alpha: 0.2).setStroke()
		shape.stroke()
		context.restoreGState()
		context.saveGState()
		shape.lineWidth = 2
		context.beginPath()
		context.addPath(shape.cgPath)
		context.addRect(shape.bounds.insetBy(dx: -20, dy: -20))
		context.clip(using: .evenOdd)
		UIColor(white: 0, alpha: 0.4).setStroke()
		shape.stroke()
		context.restoreGState()
		context.restoreGState()
		
		context.restoreGState()
	}
	
	
	//MARK: - Canvas Images
	
	/// Page 1
	
	class func imageOfDraw() -> UIImage
	{
		struct LocalCache
		{
			static var image: UIImage!
		}
		if LocalCache.image != nil
		{
			return LocalCache.image
		}
		var image: UIImage
		
		UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
		Dial.drawDraw()
		image = UIGraphicsGetImageFromCurrentImageContext()!
		UIGraphicsEndImageContext()
		
		LocalCache.image = image
		return image
	}
	
	
	//MARK: - Resizing Behavior
	
	enum ResizingBehavior
	{
		case aspectFit /// The content is proportionally resized to fit into the target rectangle.
		case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
		case stretch /// The content is stretched to match the entire target rectangle.
		case center /// The content is centered in the target rectangle, but it is NOT resized.
		
		func apply(rect: CGRect, target: CGRect) -> CGRect
		{
			if rect == target || target == CGRect.zero
			{
				return rect
			}
			
			var scales = CGSize.zero
			scales.width = abs(target.width / rect.width)
			scales.height = abs(target.height / rect.height)
			
			switch self
			{
				case .aspectFit:
					scales.width = min(scales.width, scales.height)
					scales.height = scales.width
				case .aspectFill:
					scales.width = max(scales.width, scales.height)
					scales.height = scales.width
				case .stretch:
					break
				case .center:
					scales.width = 1
					scales.height = 1
			}
			
			var result = rect.standardized
			result.size.width *= scales.width
			result.size.height *= scales.height
			result.origin.x = target.minX + (target.width - result.width) / 2
			result.origin.y = target.minY + (target.height - result.height) / 2
			return result
		}
	}
	
	
}
