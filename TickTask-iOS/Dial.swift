////
////  Dial.swift
////
////  Created on May 25, 2019.
////
////  Generated by PaintCode Plugin for Sketch
////  http://www.paintcodeapp.com/sketch
////
//
//import UIKit
//
//
//
//class Dial: NSObject
//{
//
//
//    //MARK: - Canvas Drawings
//
//    /// Page 1
//
//    class func drawDraw(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit)
//    {
//        /// General Declarations
//        let context = UIGraphicsGetCurrentContext()!
//        let baseTransform = context.userSpaceToDeviceSpaceTransform.inverted()
//
//        /// Resize to Target Frame
//        context.saveGState()
//        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
//        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
//        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)
//
//        /// tickTask-oval5
//        let tickTaskoval5 = UIBezierPath()
//        tickTaskoval5.move(to: CGPoint(x: 43.36, y: 86.72))
//        tickTaskoval5.addCurve(to: CGPoint(x: 86.72, y: 43.36), controlPoint1: CGPoint(x: 67.31, y: 86.72), controlPoint2: CGPoint(x: 86.72, y: 67.31))
//        tickTaskoval5.addCurve(to: CGPoint(x: 43.36, y: 0), controlPoint1: CGPoint(x: 86.72, y: 19.41), controlPoint2: CGPoint(x: 67.31, y: 0))
//        tickTaskoval5.addCurve(to: CGPoint(x: 0, y: 43.36), controlPoint1: CGPoint(x: 19.41, y: 0), controlPoint2: CGPoint(x: 0, y: 19.41))
//        tickTaskoval5.addCurve(to: CGPoint(x: 43.36, y: 86.72), controlPoint1: CGPoint(x: 0, y: 67.31), controlPoint2: CGPoint(x: 19.41, y: 86.72))
//        tickTaskoval5.close()
//        context.saveGState()
//        context.translateBy(x: 6.64, y: 6.64)
//        context.saveGState()
//        context.beginPath()
//        context.addPath(tickTaskoval5.cgPath)
//        context.addRect(tickTaskoval5.bounds.insetBy(dx: -4, dy: -6))
//        context.clip(using: .evenOdd)
//        context.translateBy(x: -91.72, y: 0)
//        do
//        {
//            let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
//            let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
//            let baseOffset = context.convertToDeviceSpace(CGPoint(x: 91.72, y: 2)).applying(baseTransform)
//            let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
//            let shadowBlur: CGFloat = 4 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
//            context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor(white: 0, alpha: 0.8).cgColor)
//        }
//        UIColor.black.setFill()
//        tickTaskoval5.fill()
//        context.restoreGState()
//        UIColor(white: 0.11, alpha: 1).setFill()
//        tickTaskoval5.fill()
//        context.restoreGState()
//
//        /// tickTask-oval
//        let tickTaskoval = UIBezierPath()
//        tickTaskoval.move(to: CGPoint(x: 43.36, y: 86.72))
//        tickTaskoval.addCurve(to: CGPoint(x: 86.72, y: 43.36), controlPoint1: CGPoint(x: 67.31, y: 86.72), controlPoint2: CGPoint(x: 86.72, y: 67.31))
//        tickTaskoval.addCurve(to: CGPoint(x: 43.36, y: 0), controlPoint1: CGPoint(x: 86.72, y: 19.41), controlPoint2: CGPoint(x: 67.31, y: 0))
//        tickTaskoval.addCurve(to: CGPoint(x: 0, y: 43.36), controlPoint1: CGPoint(x: 19.41, y: 0), controlPoint2: CGPoint(x: 0, y: 19.41))
//        tickTaskoval.addCurve(to: CGPoint(x: 43.36, y: 86.72), controlPoint1: CGPoint(x: 0, y: 67.31), controlPoint2: CGPoint(x: 19.41, y: 86.72))
//        tickTaskoval.close()
//        context.saveGState()
//        context.translateBy(x: 6.64, y: 6.64)
//        context.saveGState()
//        tickTaskoval.addClip()
//        context.drawLinearGradient(CGGradient(colorsSpace: nil, colors: [
//            UIColor(white: 1, alpha: 0.2).cgColor,
//            UIColor(white: 0, alpha: 0.4).cgColor,
//            ] as CFArray, locations: [0, 1])!,
//                                   start: CGPoint(x: 43.36, y: 0),
//                                   end: CGPoint(x: 43.36, y: 86.72),
//                                   options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
//        context.restoreGState()
//        tickTaskoval.lineWidth = 0.5
//        UIColor(white: 1, alpha: 0.3).setStroke()
//        tickTaskoval.stroke()
//        context.restoreGState()
//
//        /// tickTask-oval4
//        let tickTaskoval4 = UIBezierPath()
//        tickTaskoval4.move(to: CGPoint(x: 41.6, y: 83.2))
//        tickTaskoval4.addCurve(to: CGPoint(x: 83.2, y: 41.6), controlPoint1: CGPoint(x: 64.58, y: 83.2), controlPoint2: CGPoint(x: 83.2, y: 64.58))
//        tickTaskoval4.addCurve(to: CGPoint(x: 41.6, y: 0), controlPoint1: CGPoint(x: 83.2, y: 18.63), controlPoint2: CGPoint(x: 64.58, y: 0))
//        tickTaskoval4.addCurve(to: CGPoint(x: 0, y: 41.6), controlPoint1: CGPoint(x: 18.63, y: 0), controlPoint2: CGPoint(x: 0, y: 18.63))
//        tickTaskoval4.addCurve(to: CGPoint(x: 41.6, y: 83.2), controlPoint1: CGPoint(x: 0, y: 64.58), controlPoint2: CGPoint(x: 18.63, y: 83.2))
//        tickTaskoval4.close()
//        context.saveGState()
//        context.translateBy(x: 8.4, y: 8.4)
//        UIColor(white: 0.11, alpha: 1).setFill()
//        tickTaskoval4.fill()
//        context.restoreGState()
//
//        /// tickTask-oval2
//        let tickTaskoval2 = UIBezierPath()
//        tickTaskoval2.move(to: CGPoint(x: 39.84, y: 79.69))
//        tickTaskoval2.addCurve(to: CGPoint(x: 79.69, y: 39.84), controlPoint1: CGPoint(x: 61.85, y: 79.69), controlPoint2: CGPoint(x: 79.69, y: 61.85))
//        tickTaskoval2.addCurve(to: CGPoint(x: 39.84, y: 0), controlPoint1: CGPoint(x: 79.69, y: 17.84), controlPoint2: CGPoint(x: 61.85, y: 0))
//        tickTaskoval2.addCurve(to: CGPoint(x: 0, y: 39.84), controlPoint1: CGPoint(x: 17.84, y: 0), controlPoint2: CGPoint(x: 0, y: 17.84))
//        tickTaskoval2.addCurve(to: CGPoint(x: 39.84, y: 79.69), controlPoint1: CGPoint(x: 0, y: 61.85), controlPoint2: CGPoint(x: 17.84, y: 79.69))
//        tickTaskoval2.close()
//        context.saveGState()
//        context.translateBy(x: 10.16, y: 10.16)
//        context.saveGState()
//        tickTaskoval2.addClip()
//        context.drawLinearGradient(CGGradient(colorsSpace: nil, colors: [
//            UIColor(white: 0, alpha: 0.4).cgColor,
//            UIColor(white: 1, alpha: 0.1).cgColor,
//            ] as CFArray, locations: [0, 1])!,
//                                   start: CGPoint(x: 39.84, y: 0),
//                                   end: CGPoint(x: 39.84, y: 79.69),
//                                   options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
//        context.restoreGState()
//        context.restoreGState()
//
//        /// tickTask-oval3
//        let tickTaskoval3 = UIBezierPath()
//        tickTaskoval3.move(to: CGPoint(x: 38.09, y: 76.17))
//        tickTaskoval3.addCurve(to: CGPoint(x: 76.17, y: 38.09), controlPoint1: CGPoint(x: 59.12, y: 76.17), controlPoint2: CGPoint(x: 76.17, y: 59.12))
//        tickTaskoval3.addCurve(to: CGPoint(x: 38.09, y: 0), controlPoint1: CGPoint(x: 76.17, y: 17.05), controlPoint2: CGPoint(x: 59.12, y: 0))
//        tickTaskoval3.addCurve(to: CGPoint(x: 0, y: 38.09), controlPoint1: CGPoint(x: 17.05, y: 0), controlPoint2: CGPoint(x: 0, y: 17.05))
//        tickTaskoval3.addCurve(to: CGPoint(x: 38.09, y: 76.17), controlPoint1: CGPoint(x: 0, y: 59.12), controlPoint2: CGPoint(x: 17.05, y: 76.17))
//        tickTaskoval3.close()
//        context.saveGState()
//        context.translateBy(x: 11.91, y: 11.91)
//        UIColor(white: 0.11, alpha: 1).setFill()
//        tickTaskoval3.fill()
//        context.restoreGState()
//
//        /// Shape
//        let shape = UIBezierPath()
//        shape.move(to: CGPoint(x: 10.01, y: 31.28))
//        shape.addCurve(to: CGPoint(x: 4.99, y: 32.56), controlPoint1: CGPoint(x: 8.23, y: 30.26), controlPoint2: CGPoint(x: 5.99, y: 30.82))
//        shape.addCurve(to: CGPoint(x: 6.4, y: 37.54), controlPoint1: CGPoint(x: 3.99, y: 34.28), controlPoint2: CGPoint(x: 4.62, y: 36.52))
//        shape.addLine(to: CGPoint(x: 6.44, y: 37.57))
//        shape.addCurve(to: CGPoint(x: 11.42, y: 36.27), controlPoint1: CGPoint(x: 8.21, y: 38.56), controlPoint2: CGPoint(x: 10.43, y: 37.98))
//        shape.addCurve(to: CGPoint(x: 10.01, y: 31.28), controlPoint1: CGPoint(x: 12.42, y: 34.53), controlPoint2: CGPoint(x: 11.78, y: 32.31))
//        shape.close()
//        shape.move(to: CGPoint(x: 10.68, y: 2.08))
//        shape.addCurve(to: CGPoint(x: 16.26, y: 32.68), controlPoint1: CGPoint(x: 10.98, y: 3.3), controlPoint2: CGPoint(x: 16.26, y: 32.68))
//        shape.addCurve(to: CGPoint(x: 8.2, y: 42.38), controlPoint1: CGPoint(x: 17.24, y: 38.14), controlPoint2: CGPoint(x: 13.13, y: 42.38))
//        shape.addCurve(to: CGPoint(x: 0.15, y: 32.68), controlPoint1: CGPoint(x: 3.29, y: 42.38), controlPoint2: CGPoint(x: -0.84, y: 38.14))
//        shape.addCurve(to: CGPoint(x: 5.72, y: 2.08), controlPoint1: CGPoint(x: 0.15, y: 32.68), controlPoint2: CGPoint(x: 5.56, y: 2.74))
//        shape.addCurve(to: CGPoint(x: 8.2, y: 0), controlPoint1: CGPoint(x: 6.03, y: 0.85), controlPoint2: CGPoint(x: 6.93, y: 0))
//        shape.addCurve(to: CGPoint(x: 10.68, y: 2.08), controlPoint1: CGPoint(x: 9.47, y: 0), controlPoint2: CGPoint(x: 10.38, y: 0.85))
//        shape.close()
//        context.saveGState()
//        context.translateBy(x: 41.8, y: 15.69)
//        context.saveGState()
//        context.beginPath()
//        context.addPath(shape.cgPath)
//        context.addRect(shape.bounds.insetBy(dx: -22, dy: -23))
//        context.clip(using: .evenOdd)
//        context.translateBy(x: -59.41, y: 0)
//        do
//        {
//            let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
//            let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
//            let baseOffset = context.convertToDeviceSpace(CGPoint(x: 59.41, y: 1)).applying(baseTransform)
//            let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
//            let shadowBlur: CGFloat = 2 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
//            context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor(white: 0, alpha: 0.2).cgColor)
//        }
//        context.beginTransparencyLayer(auxiliaryInfo: nil)
//        do
//        {
//            UIColor.black.setFill()
//            shape.fill()
//            context.saveGState()
//            shape.lineWidth = 2
//            UIColor.black.setStroke()
//            shape.stroke()
//            context.restoreGState()
//        }
//        context.endTransparencyLayer()
//        context.restoreGState()
//        context.saveGState()
//        context.beginPath()
//        context.addPath(shape.cgPath)
//        context.addRect(shape.bounds.insetBy(dx: -26, dy: -24))
//        context.clip(using: .evenOdd)
//        context.translateBy(x: -63.41, y: 0)
//        do
//        {
//            let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
//            let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
//            let baseOffset = context.convertToDeviceSpace(CGPoint(x: 65.41, y: 0)).applying(baseTransform)
//            let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
//            let shadowBlur: CGFloat = 4 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
//            context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor(white: 0, alpha: 0.5).cgColor)
//        }
//        context.beginTransparencyLayer(auxiliaryInfo: nil)
//        do
//        {
//            UIColor.black.setFill()
//            shape.fill()
//            context.saveGState()
//            shape.lineWidth = 2
//            UIColor.black.setStroke()
//            shape.stroke()
//            context.restoreGState()
//        }
//        context.endTransparencyLayer()
//        context.restoreGState()
//        UIColor(hue: 0.42, saturation: 0.9, brightness: 1, alpha: 1).setFill()
//        shape.fill()
//        context.saveGState()
//        UIRectClip(shape.bounds)
//        context.setShadow(offset: CGSize.zero, blur: 0, color: nil)
//        context.setAlpha(0.5)
//        context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
//        do
//        {
//            UIColor.white.setFill()
//            shape.fill()
//            context.setBlendMode(.destinationOut)
//            context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
//            do
//            {
//                context.translateBy(x: -16.41, y: 0)
//                do
//                {
//                    let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
//                    let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
//                    let baseOffset = context.convertToDeviceSpace(CGPoint(x: 16.41, y: 1)).applying(baseTransform)
//                    let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
//                    let shadowBlur: CGFloat = 0 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
//                    context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor.black.cgColor)
//                }
//                UIColor.black.setFill()
//                shape.fill()
//            }
//            context.endTransparencyLayer()
//        }
//        context.endTransparencyLayer()
//        context.restoreGState()
//        context.saveGState()
//        UIRectClip(shape.bounds)
//        context.setShadow(offset: CGSize.zero, blur: 0, color: nil)
//        context.setAlpha(0.5)
//        context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
//        do
//        {
//            UIColor.black.setFill()
//            shape.fill()
//            context.setBlendMode(.destinationOut)
//            context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
//            do
//            {
//                context.translateBy(x: -16.41, y: 0)
//                do
//                {
//                    let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
//                    let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
//                    let baseOffset = context.convertToDeviceSpace(CGPoint(x: 16.41, y: -1)).applying(baseTransform)
//                    let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
//                    let shadowBlur: CGFloat = 0 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
//                    context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor.black.cgColor)
//                }
//                UIColor.black.setFill()
//                shape.fill()
//            }
//            context.endTransparencyLayer()
//        }
//        context.endTransparencyLayer()
//        context.restoreGState()
//        context.saveGState()
//        shape.lineWidth = 2
//        context.beginPath()
//        context.addPath(shape.cgPath)
//        context.clip(using: .evenOdd)
//        UIColor(white: 1, alpha: 0.2).setStroke()
//        shape.stroke()
//        context.restoreGState()
//        context.saveGState()
//        shape.lineWidth = 2
//        context.beginPath()
//        context.addPath(shape.cgPath)
//        context.addRect(shape.bounds.insetBy(dx: -20, dy: -20))
//        context.clip(using: .evenOdd)
//        UIColor(white: 0, alpha: 0.4).setStroke()
//        shape.stroke()
//        context.restoreGState()
//        context.restoreGState()
//
//        context.restoreGState()
//    }
//
//
//    //MARK: - Canvas Images
//
//    /// Page 1
//
//    class func imageOfDraw() -> UIImage
//    {
//        struct LocalCache
//        {
//            static var image: UIImage!
//        }
//        if LocalCache.image != nil
//        {
//            return LocalCache.image
//        }
//        var image: UIImage
//
//        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
//        Dial.drawDraw()
//        image = UIGraphicsGetImageFromCurrentImageContext()!
//        UIGraphicsEndImageContext()
//
//        LocalCache.image = image
//        return image
//    }
//
//
//    //MARK: - Resizing Behavior
//
//    enum ResizingBehavior
//    {
//        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
//        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
//        case stretch /// The content is stretched to match the entire target rectangle.
//        case center /// The content is centered in the target rectangle, but it is NOT resized.
//
//        func apply(rect: CGRect, target: CGRect) -> CGRect
//        {
//            if rect == target || target == CGRect.zero
//            {
//                return rect
//            }
//
//            var scales = CGSize.zero
//            scales.width = abs(target.width / rect.width)
//            scales.height = abs(target.height / rect.height)
//
//            switch self
//            {
//            case .aspectFit:
//                scales.width = min(scales.width, scales.height)
//                scales.height = scales.width
//            case .aspectFill:
//                scales.width = max(scales.width, scales.height)
//                scales.height = scales.width
//            case .stretch:
//                break
//            case .center:
//                scales.width = 1
//                scales.height = 1
//            }
//
//            var result = rect.standardized
//            result.size.width *= scales.width
//            result.size.height *= scales.height
//            result.origin.x = target.minX + (target.width - result.width) / 2
//            result.origin.y = target.minY + (target.height - result.height) / 2
//            return result
//        }
//    }
//
//
//}











import UIKit

class Dial: NSObject
{


    //MARK: - Canvas Drawings

    fileprivate static func func1(_ context: CGContext, _ tickTaskoval5: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.saveGState()
        context.beginPath()
        context.addPath(tickTaskoval5.cgPath)
        context.addRect(tickTaskoval5.bounds.insetBy(dx: -4, dy: -6))
        context.clip(using: .evenOdd)
        context.translateBy(x: -91.72, y: 0)
        do
        {
            let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
            let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
            let baseOffset = context.convertToDeviceSpace(CGPoint(x: 91.72, y: 2)).applying(baseTransform)
            let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
            let shadowBlur: CGFloat = 4 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
            context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor(white: 0, alpha: 0.8).cgColor)
        }
        UIColor.black.setFill()
        tickTaskoval5.fill()
        context.restoreGState()
}

    fileprivate static func func2(_ context: CGContext, _ tickTaskoval5: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.saveGState()
        context.translateBy(x: 6.64, y: 6.64)
        func1(context, tickTaskoval5, baseTransform)
        UIColor(white: 0.11, alpha: 1).setFill()
        tickTaskoval5.fill()
        context.restoreGState()
}

    fileprivate static func func3(_ context: CGContext, _ tickTaskoval: UIBezierPath) {
        context.saveGState()
        context.translateBy(x: 6.64, y: 6.64)
        context.saveGState()
        tickTaskoval.addClip()
        context.drawLinearGradient(CGGradient(colorsSpace: nil, colors: [
            UIColor(white: 1, alpha: 0.2).cgColor,
            UIColor(white: 0, alpha: 0.4).cgColor,
            ] as CFArray, locations: [0, 1])!,
                                   start: CGPoint(x: 43.36, y: 0),
                                   end: CGPoint(x: 43.36, y: 86.72),
                                   options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
        tickTaskoval.lineWidth = 0.5
        UIColor(white: 1, alpha: 0.3).setStroke()
        tickTaskoval.stroke()
        context.restoreGState()
}

    fileprivate static func func4(_ context: CGContext, _ tickTaskoval4: UIBezierPath) {
        context.saveGState()
        context.translateBy(x: 8.4, y: 8.4)
        UIColor(white: 0.11, alpha: 1).setFill()
        tickTaskoval4.fill()
        context.restoreGState()
}

    fileprivate static func func5(_ context: CGContext, _ tickTaskoval2: UIBezierPath) {
        context.saveGState()
        tickTaskoval2.addClip()
        context.drawLinearGradient(CGGradient(colorsSpace: nil, colors: [
            UIColor(white: 0, alpha: 0.4).cgColor,
            UIColor(white: 1, alpha: 0.1).cgColor,
            ] as CFArray, locations: [0, 1])!,
                                   start: CGPoint(x: 39.84, y: 0),
                                   end: CGPoint(x: 39.84, y: 79.69),
                                   options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
}

    fileprivate static func func6(_ context: CGContext, _ tickTaskoval2: UIBezierPath) {
        context.saveGState()
        context.translateBy(x: 10.16, y: 10.16)
        func5(context, tickTaskoval2)
        context.restoreGState()
}

    fileprivate static func func7(_ context: CGContext, _ tickTaskoval3: UIBezierPath) {
        context.saveGState()
        context.translateBy(x: 11.91, y: 11.91)
        UIColor(white: 0.11, alpha: 1).setFill()
        tickTaskoval3.fill()
        context.restoreGState()
}

    fileprivate static func transparency1(_ context: CGContext, _ shape: UIBezierPath) {
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        do
        {
            UIColor.black.setFill()
            shape.fill()
            context.saveGState()
            shape.lineWidth = 2
            UIColor.black.setStroke()
            shape.stroke()
            context.restoreGState()
        }
        context.endTransparencyLayer()
}

    fileprivate static func transparency2(_ context: CGContext, _ shape: UIBezierPath) {
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        do
        {
            UIColor.black.setFill()
            shape.fill()
            context.saveGState()
            shape.lineWidth = 2
            UIColor.black.setStroke()
            shape.stroke()
            context.restoreGState()
        }
        context.endTransparencyLayer()
}

    fileprivate static func transparency3(_ context: CGContext, _ shape: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
        do
        {
            context.translateBy(x: -16.41, y: 0)
            do
            {
                let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
                let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
                let baseOffset = context.convertToDeviceSpace(CGPoint(x: 16.41, y: 1)).applying(baseTransform)
                let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
                let shadowBlur: CGFloat = 0 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
                context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor.black.cgColor)
                }
                UIColor.black.setFill()
                shape.fill()
            }
            context.endTransparencyLayer()
}

    fileprivate static func transparency4(_ context: CGContext, _ shape: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
        do
        {
            UIColor.white.setFill()
            shape.fill()
            context.setBlendMode(.destinationOut)
            transparency3(context, shape, baseTransform)
        }
        context.endTransparencyLayer()
}

    fileprivate static func transparency5(_ context: CGContext, _ shape: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
        do
        {
            context.translateBy(x: -16.41, y: 0)
            do
            {
                let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
                let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
                let baseOffset = context.convertToDeviceSpace(CGPoint(x: 16.41, y: -1)).applying(baseTransform)
                let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
                let shadowBlur: CGFloat = 0 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
                context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor.black.cgColor)
                }
                UIColor.black.setFill()
                shape.fill()
            }
            context.endTransparencyLayer()
}

    fileprivate static func transparency6(_ context: CGContext, _ shape: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.beginTransparencyLayer(in: shape.bounds, auxiliaryInfo: nil)
        do
        {
            UIColor.black.setFill()
            shape.fill()
            context.setBlendMode(.destinationOut)
            transparency5(context, shape, baseTransform)
        }
        context.endTransparencyLayer()
}

    fileprivate static func save1(_ context: CGContext, _ shape: UIBezierPath) {
        context.saveGState()
        shape.lineWidth = 2
        context.beginPath()
        context.addPath(shape.cgPath)
        context.addRect(shape.bounds.insetBy(dx: -20, dy: -20))
        context.clip(using: .evenOdd)
        UIColor(white: 0, alpha: 0.4).setStroke()
        shape.stroke()
        context.restoreGState()
}

    fileprivate static func save2(_ context: CGContext, _ shape: UIBezierPath) {
        context.saveGState()
        shape.lineWidth = 2
        context.beginPath()
        context.addPath(shape.cgPath)
        context.clip(using: .evenOdd)
        UIColor(white: 1, alpha: 0.2).setStroke()
        shape.stroke()
        context.restoreGState()
}

    fileprivate static func save3(_ context: CGContext, _ shape: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.saveGState()
        UIRectClip(shape.bounds)
        context.setShadow(offset: CGSize.zero, blur: 0, color: nil)
        context.setAlpha(0.5)
        transparency6(context, shape, baseTransform)
        context.restoreGState()
}

    fileprivate static func save4(_ context: CGContext, _ shape: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.saveGState()
        UIRectClip(shape.bounds)
        context.setShadow(offset: CGSize.zero, blur: 0, color: nil)
        context.setAlpha(0.5)
        transparency4(context, shape, baseTransform)
        context.restoreGState()
}

    fileprivate static func save5(_ context: CGContext, _ shape: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.saveGState()
        context.beginPath()
        context.addPath(shape.cgPath)
        context.addRect(shape.bounds.insetBy(dx: -26, dy: -24))
        context.clip(using: .evenOdd)
        context.translateBy(x: -63.41, y: 0)
        do
        {
            let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
            let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
            let baseOffset = context.convertToDeviceSpace(CGPoint(x: 65.41, y: 0)).applying(baseTransform)
            let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
            let shadowBlur: CGFloat = 4 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
            context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor(white: 0, alpha: 0.5).cgColor)
        }
        transparency2(context, shape)
        context.restoreGState()
}

    fileprivate static func save6(_ context: CGContext, _ shape: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.saveGState()
        context.beginPath()
        context.addPath(shape.cgPath)
        context.addRect(shape.bounds.insetBy(dx: -22, dy: -23))
        context.clip(using: .evenOdd)
        context.translateBy(x: -59.41, y: 0)
        do
        {
            let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
            let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
            let baseOffset = context.convertToDeviceSpace(CGPoint(x: 59.41, y: 1)).applying(baseTransform)
            let shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
            let shadowBlur: CGFloat = 2 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
            context.setShadow(offset: shadowOffset, blur: shadowBlur, color: UIColor(white: 0, alpha: 0.2).cgColor)
        }
        transparency1(context, shape)
        context.restoreGState()
}

    fileprivate static func save7(_ context: CGContext, _ shape: UIBezierPath, _ baseTransform: CGAffineTransform) {
        context.saveGState()
        context.translateBy(x: 41.8, y: 15.69)
        save6(context, shape, baseTransform)
        save5(context, shape, baseTransform)
        UIColor(hue: 0.42, saturation: 0.9, brightness: 1, alpha: 1).setFill()
        shape.fill()
        save4(context, shape, baseTransform)
        save3(context, shape, baseTransform)
        save2(context, shape)
        save1(context, shape)
        context.restoreGState()
}

/// Page 1

    class func drawDraw(frame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100))
    {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        let baseTransform = context.userSpaceToDeviceSpaceTransform.inverted()

        /// Resize to Target Frame
//        context.saveGState()
//        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
//        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
//        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)

        let offset: CGFloat = 13.28 // abitrary, might be the shadowblur + shadowOffset, as well as the circle radius...

        let borderWidth: CGFloat = 3.52

        /// tickTask-oval5
//        let tickTaskoval5 = UIBezierPath()
//        tickTaskoval5.move(to: CGPoint(x: 43.36, y: 86.72))
//        tickTaskoval5.addCurve(to: CGPoint(x: 86.72, y: 43.36), controlPoint1: CGPoint(x: 67.31, y: 86.72), controlPoint2: CGPoint(x: 86.72, y: 67.31))
//        tickTaskoval5.addCurve(to: CGPoint(x: 43.36, y: 0), controlPoint1: CGPoint(x: 86.72, y: 19.41), controlPoint2: CGPoint(x: 67.31, y: 0))
//        tickTaskoval5.addCurve(to: CGPoint(x: 0, y: 43.36), controlPoint1: CGPoint(x: 19.41, y: 0), controlPoint2: CGPoint(x: 0, y: 19.41))
//        tickTaskoval5.addCurve(to: CGPoint(x: 43.36, y: 86.72), controlPoint1: CGPoint(x: 0, y: 67.31), controlPoint2: CGPoint(x: 19.41, y: 86.72))
//        tickTaskoval5.close()

        let tickTaskoval5 = UIBezierPath(ovalIn: CGRect(x: (offset + borderWidth * 0),
                                                        y: (offset + borderWidth * 0),
                                                        width: frame.size.width - offset * 2,
                                                        height: frame.size.height - offset * 2))

        func2(context, tickTaskoval5, baseTransform)

        /// tickTask-oval
//        let tickTaskoval = UIBezierPath()
//        tickTaskoval.move(to: CGPoint(x: 43.36, y: 86.72))
//        tickTaskoval.addCurve(to: CGPoint(x: 86.72, y: 43.36), controlPoint1: CGPoint(x: 67.31, y: 86.72), controlPoint2: CGPoint(x: 86.72, y: 67.31))
//        tickTaskoval.addCurve(to: CGPoint(x: 43.36, y: 0), controlPoint1: CGPoint(x: 86.72, y: 19.41), controlPoint2: CGPoint(x: 67.31, y: 0))
//        tickTaskoval.addCurve(to: CGPoint(x: 0, y: 43.36), controlPoint1: CGPoint(x: 19.41, y: 0), controlPoint2: CGPoint(x: 0, y: 19.41))
//        tickTaskoval.addCurve(to: CGPoint(x: 43.36, y: 86.72), controlPoint1: CGPoint(x: 0, y: 67.31), controlPoint2: CGPoint(x: 19.41, y: 86.72))
//        tickTaskoval.close()

        let tickTaskoval = UIBezierPath(ovalIn: CGRect(x: (offset + borderWidth * 0),
                                                       y: (offset + borderWidth * 0),
                                                       width: frame.size.width - offset * 2,
                                                       height: frame.size.height - offset * 2))

        func3(context, tickTaskoval)



        /// tickTask-oval4
//        let tickTaskoval4 = UIBezierPath()
//        tickTaskoval4.move(to: CGPoint(x: 41.6, y: 83.2))
//        tickTaskoval4.addCurve(to: CGPoint(x: 83.2, y: 41.6), controlPoint1: CGPoint(x: 64.58, y: 83.2), controlPoint2: CGPoint(x: 83.2, y: 64.58))
//        tickTaskoval4.addCurve(to: CGPoint(x: 41.6, y: 0), controlPoint1: CGPoint(x: 83.2, y: 18.63), controlPoint2: CGPoint(x: 64.58, y: 0))
//        tickTaskoval4.addCurve(to: CGPoint(x: 0, y: 41.6), controlPoint1: CGPoint(x: 18.63, y: 0), controlPoint2: CGPoint(x: 0, y: 18.63))
//        tickTaskoval4.addCurve(to: CGPoint(x: 41.6, y: 83.2), controlPoint1: CGPoint(x: 0, y: 64.58), controlPoint2: CGPoint(x: 18.63, y: 83.2))
//        tickTaskoval4.close()

        let tickTaskoval4 = UIBezierPath(ovalIn: CGRect(x: (offset + borderWidth * 1),
                                                        y: (offset + borderWidth * 1),
                                                        width: frame.size.width - (offset + borderWidth * 1),
                                                        height: frame.size.height - (offset + borderWidth * 1)))

        func4(context, tickTaskoval4)

        /// tickTask-oval2
//        let tickTaskoval2 = UIBezierPath()
//        tickTaskoval2.move(to: CGPoint(x: 39.84, y: 79.69))
//        tickTaskoval2.addCurve(to: CGPoint(x: 79.69, y: 39.84), controlPoint1: CGPoint(x: 61.85, y: 79.69), controlPoint2: CGPoint(x: 79.69, y: 61.85))
//        tickTaskoval2.addCurve(to: CGPoint(x: 39.84, y: 0), controlPoint1: CGPoint(x: 79.69, y: 17.84), controlPoint2: CGPoint(x: 61.85, y: 0))
//        tickTaskoval2.addCurve(to: CGPoint(x: 0, y: 39.84), controlPoint1: CGPoint(x: 17.84, y: 0), controlPoint2: CGPoint(x: 0, y: 17.84))
//        tickTaskoval2.addCurve(to: CGPoint(x: 39.84, y: 79.69), controlPoint1: CGPoint(x: 0, y: 61.85), controlPoint2: CGPoint(x: 17.84, y: 79.69))
//        tickTaskoval2.close()

        let tickTaskoval2 = UIBezierPath(ovalIn: CGRect(x: (offset + borderWidth * 2),
                                                        y: (offset + borderWidth * 2),
                                                        width: frame.size.width - (offset + borderWidth * 2),
                                                        height: frame.size.height - (offset + borderWidth * 2)))

        func6(context, tickTaskoval2)

        /// tickTask-oval3
//        let tickTaskoval3 = UIBezierPath()
//        tickTaskoval3.move(to: CGPoint(x: 38.09, y: 76.17))
//        tickTaskoval3.addCurve(to: CGPoint(x: 76.17, y: 38.09), controlPoint1: CGPoint(x: 59.12, y: 76.17), controlPoint2: CGPoint(x: 76.17, y: 59.12))
//        tickTaskoval3.addCurve(to: CGPoint(x: 38.09, y: 0), controlPoint1: CGPoint(x: 76.17, y: 17.05), controlPoint2: CGPoint(x: 59.12, y: 0))
//        tickTaskoval3.addCurve(to: CGPoint(x: 0, y: 38.09), controlPoint1: CGPoint(x: 17.05, y: 0), controlPoint2: CGPoint(x: 0, y: 17.05))
//        tickTaskoval3.addCurve(to: CGPoint(x: 38.09, y: 76.17), controlPoint1: CGPoint(x: 0, y: 59.12), controlPoint2: CGPoint(x: 17.05, y: 76.17))
//        tickTaskoval3.close()
        let tickTaskoval3 = UIBezierPath(ovalIn: CGRect(x: (offset + borderWidth * 3),
                                                        y: (offset + borderWidth * 3),
                                                        width: frame.size.width - (offset + borderWidth * 3),
                                                        height: frame.size.height - (offset + borderWidth * 3)))
        func7(context, tickTaskoval3)

        /// Shape
        let shape = UIBezierPath()
//        shape.move(to: CGPoint(x: 10.01, y: 31.28))
//        shape.addCurve(to: CGPoint(x: 4.99, y: 32.56), controlPoint1: CGPoint(x: 8.23, y: 30.26), controlPoint2: CGPoint(x: 5.99, y: 30.82))
//        shape.addCurve(to: CGPoint(x: 6.4, y: 37.54), controlPoint1: CGPoint(x: 3.99, y: 34.28), controlPoint2: CGPoint(x: 4.62, y: 36.52))
//        shape.addCurve(to: CGPoint(x: 11.42, y: 36.27), controlPoint1: CGPoint(x: 8.21, y: 38.56), controlPoint2: CGPoint(x: 10.43, y: 37.98))
//        shape.addCurve(to: CGPoint(x: 10.01, y: 31.28), controlPoint1: CGPoint(x: 12.42, y: 34.53), controlPoint2: CGPoint(x: 11.78, y: 32.31))
//        shape.close()

        // Drawing the inner circle
//
        shape.addArc(withCenter: CGPoint(x: frame.size.width / 2,
                                         y: frame.size.height / 2),
                     radius: 3.69, // Just taken from the sketch document
                     startAngle: 0,
                     endAngle: CGFloat.pi * 2,
                     clockwise: false)

        shape.close()

        // These numbers are not exact. As a result, once we tweak them to be exact, we should
        // modify the symbol in the Sketch project to make sure they comply exactly

        let dialLength: CGFloat = 32 // The length from the midpoints of the circles
        let bodyRadius: CGFloat = 8.205
        let tipRadius: CGFloat = 2.35 // Estimated

        let bodyCenter = CGPoint.zero
        let tipCenter = CGPoint(x: 0, y: -dialLength)

        let distanceCenters = bodyCenter.distance(to: tipCenter)
        let differenceRadius = (bodyRadius - tipRadius)

        // We use the pythagorean theorem to find the third side of a right triangle
        // a^2 + b^2 = c^2
        // In this case, we have a^2 and c^2 but not b^2
        let distanceTangents = (distanceCenters.squared - differenceRadius.squared).squareRoot()

        // Now we use the law of sines to find the angle that the tangent is from the center of the circle
        let theta = asin(distanceTangents / distanceCenters)

        // We have to get the angle that is 90° - theta
        let thetaComplement = (CGFloat.pi / 2) - theta

        // Move to the top of the dial

        // Drawing the dial shape

        let bodyRight = CGPoint(x: bodyCenter.x + bodyRadius * cos(thetaComplement),
                                y: bodyCenter.y - bodyRadius * sin(thetaComplement))

        shape.move(to: bodyRight)

        shape.addArc(withCenter: bodyCenter,
                    radius: bodyRadius,
                    startAngle: -thetaComplement,
                    endAngle: CGFloat.pi + thetaComplement,
                    clockwise: true)
        shape.addArc(withCenter: tipCenter,
                    radius: tipRadius,
                    startAngle: CGFloat.pi + thetaComplement, endAngle: -thetaComplement, clockwise: true)
        shape.close()

//        shape.move(to: CGPoint(x: 10.68, y: 2.08))
//        shape.addCurve(to: CGPoint(x: 16.26, y: 32.68), controlPoint1: CGPoint(x: 10.98, y: 3.3), controlPoint2: CGPoint(x: 16.26, y: 32.68))
//        shape.addCurve(to: CGPoint(x: 8.2, y: 42.38), controlPoint1: CGPoint(x: 17.24, y: 38.14), controlPoint2: CGPoint(x: 13.13, y: 42.38))
//        shape.addCurve(to: CGPoint(x: 0.15, y: 32.68), controlPoint1: CGPoint(x: 3.29, y: 42.38), controlPoint2: CGPoint(x: -0.84, y: 38.14))
//        shape.addCurve(to: CGPoint(x: 5.72, y: 2.08), controlPoint1: CGPoint(x: 0.15, y: 32.68), controlPoint2: CGPoint(x: 5.56, y: 2.74))
//        shape.addCurve(to: CGPoint(x: 8.2, y: 0), controlPoint1: CGPoint(x: 6.03, y: 0.85), controlPoint2: CGPoint(x: 6.93, y: 0))
//        shape.addCurve(to: CGPoint(x: 10.68, y: 2.08), controlPoint1: CGPoint(x: 9.47, y: 0), controlPoint2: CGPoint(x: 10.38, y: 0.85))
//        shape.close()

        save7(context, shape, baseTransform)

//        context.restoreGState()
    }


    //MARK: - Canvas Images

    /// Page 1

//    class func imageOfDraw() -> UIImage
//    {
//        struct LocalCache
//        {
//            static var image: UIImage!
//        }
//        if LocalCache.image != nil
//        {
//            return LocalCache.image
//        }
//        var image: UIImage
//
//        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
//        Dial.drawDraw()
//        image = UIGraphicsGetImageFromCurrentImageContext()!
//        UIGraphicsEndImageContext()
//
//        LocalCache.image = image
//        return image
//    }


    //MARK: - Resizing Behavior

//    enum ResizingBehavior
//    {
//        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
//        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
//        case stretch /// The content is stretched to match the entire target rectangle.
//        case center /// The content is centered in the target rectangle, but it is NOT resized.
//
//        func apply(rect: CGRect, target: CGRect) -> CGRect
//        {
//            if rect == target || target == CGRect.zero
//            {
//                return rect
//            }
//
//            var scales = CGSize.zero
//            scales.width = abs(target.width / rect.width)
//            scales.height = abs(target.height / rect.height)
//
//            switch self
//            {
//                case .aspectFit:
//                    scales.width = min(scales.width, scales.height)
//                    scales.height = scales.width
//                case .aspectFill:
//                    scales.width = max(scales.width, scales.height)
//                    scales.height = scales.width
//                case .stretch:
//                    break
//                case .center:
//                    scales.width = 1
//                    scales.height = 1
//            }
//
//            var result = rect.standardized
//            result.size.width *= scales.width
//            result.size.height *= scales.height
//            result.origin.x = target.minX + (target.width - result.width) / 2
//            result.origin.y = target.minY + (target.height - result.height) / 2
//            return result
//        }
//    }


}
